<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Itin√©raire pr√©cis du Job</title>
<style>
html, body, #map {
	height: 100%;
	margin: 0;
	padding: 0;
}

.draggable-panel {
	position: absolute;
	z-index: 1000;
	background: white;
	border-radius: 8px;
	box-shadow: 0 4px 20px rgba(0,0,0,0.15);
	user-select: none;
	transition: all 0.3s ease;
}

.draggable-panel:hover {
	box-shadow: 0 6px 25px rgba(0,0,0,0.2);
}

.panel-header {
	background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
	color: white;
	padding: 12px 15px;
	border-radius: 8px 8px 0 0;
	cursor: move;
	display: flex;
	justify-content: space-between;
	align-items: center;
	font-weight: 600;
	font-size: 14px;
}

.panel-content {
	padding: 15px;
	max-height: 400px;
	overflow-y: auto;
}

.collapse-btn {
	background: rgba(255,255,255,0.2);
	border: none;
	color: white;
	width: 24px;
	height: 24px;
	border-radius: 50%;
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
	transition: background 0.2s ease;
	font-size: 12px;
}

.collapse-btn:hover {
	background: rgba(255,255,255,0.3);
}

.collapsed .panel-content {
	display: none;
}

.collapsed {
	border-radius: 8px;
}

.collapsed .panel-header {
	border-radius: 8px;
}

#controls {
	top: 10px;
	left: 10px;
	min-width: 200px;
}

#legend {
	bottom: 10px;
	left: 10px;
	min-width: 220px;
}

#controls label {
	display: flex;
	align-items: center;
	margin: 8px 0;
	cursor: pointer;
	padding: 5px;
	border-radius: 4px;
	transition: background 0.2s ease;
}

#controls label:hover {
	background: rgba(102, 126, 234, 0.1);
}

#controls input[type="checkbox"] {
	margin-right: 10px;
	transform: scale(1.2);
}

.legend-item {
	display: flex;
	align-items: center;
	margin: 8px 0;
	padding: 4px 0;
}

.legend-color {
	width: 20px;
	height: 3px;
	margin-right: 12px;
	border-radius: 2px;
	box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.legend-icon {
	margin-right: 12px;
	box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.panel-minimize {
	position: fixed;
	top: 50%;
	right: 10px;
	transform: translateY(-50%);
	background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
	color: white;
	border: none;
	padding: 10px;
	border-radius: 50%;
	cursor: pointer;
	box-shadow: 0 4px 15px rgba(0,0,0,0.2);
	display: none;
	z-index: 1001;
	transition: all 0.3s ease;
}

.panel-minimize:hover {
	transform: translateY(-50%) scale(1.1);
}

.panel-minimize.show {
	display: block;
}

.resize-handle {
	position: absolute;
	bottom: 0;
	right: 0;
	width: 20px;
	height: 20px;
	cursor: se-resize;
	background: linear-gradient(135deg, transparent 0%, transparent 30%, #ccc 30%, #ccc 35%, transparent 35%, transparent 65%, #ccc 65%, #ccc 70%, transparent 70%);
}

@media (max-width: 768px) {
	.draggable-panel {
		position: fixed !important;
		max-width: 90vw;
	}
	
	#controls {
		top: 5px !important;
		left: 5px !important;
	}
	
	#legend {
		bottom: 5px !important;
		left: 5px !important;
	}
}
</style>
</head>
<body>
	<div id="map"></div>

	<div id="controls" class="draggable-panel collapsed">
		<div class="panel-header">
			<span>üéõÔ∏è Contr√¥les</span>
			<button class="collapse-btn" onclick="togglePanel('controls')">‚àí</button>
		</div>
		<div class="panel-content">
			<label>
				<input type="checkbox" id="showActual" checked> 
				<span>Itin√©raire r√©el</span>
			</label>
			<label>
				<input type="checkbox" id="showEstimated" checked> 
				<span>Itin√©raire estim√©</span>
			</label>
		</div>
		<div class="resize-handle"></div>
	</div>

	<div id="legend" class="draggable-panel collapsed">
		<div class="panel-header">
			<span>üìç L√©gende</span>
			<button class="collapse-btn" onclick="togglePanel('legend')">‚àí</button>
		</div>
		<div class="panel-content">
			<div class="legend-item">
				<div class="legend-color" style="background-color: #007bff;"></div>
				<span>Itin√©raire r√©el</span>
			</div>
			<div class="legend-item">
				<div class="legend-color" style="background-color: #28a745;"></div>
				<span>Itin√©raire estim√©</span>
			</div>
			<div class="legend-item">
				<div class="legend-icon" style="width: 16px; height: 16px; background-color: #dc3545; border-radius: 50%;"></div>
				<span>Points r√©els</span>
			</div>
			<div class="legend-item">
				<div class="legend-icon" style="width: 16px; height: 16px; background-color: #28a745; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 10px; font-weight: bold;">A</div>
				<span>Sites estim√©s arriv√©s</span>
			</div>
			<div class="legend-item">
				<div class="legend-icon" style="width: 16px; height: 16px; background-color: #dc3545; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 10px; font-weight: bold;">A</div>
				<span>Sites estim√©s non arriv√©s</span>
			</div>
		</div>
		<div class="resize-handle"></div>
	</div>

	<button id="restorePanels" class="panel-minimize">
		<span style="font-size: 18px;">‚öôÔ∏è</span>
	</button>

	<script>
let map;
let directionsService;
let directionsRenderer;
let estimatedDirectionsRenderer;
const MAX_WAYPOINTS = 23;

// Store polylines and markers for toggling visibility
let actualPolylines = [];
let estimatedPolylines = [];
let estimatedMarkers = [];
let actualMarkers = [];
let actualPoints = []; // store real itinerary points for distance check

// Panel management
let draggedPanel = null;
let isDragging = false;
let dragOffset = { x: 0, y: 0 };

function getJobIdFromURL() {
  const params = new URLSearchParams(window.location.search);
  return params.get("jobId");
}

function initMap() {
  map = new google.maps.Map(document.getElementById("map"), {
    zoom: 6,
    center: { lat: 33.6, lng: -7.6 },
  });

  directionsService = new google.maps.DirectionsService();
  directionsRenderer = new google.maps.DirectionsRenderer({
    map: map,
    suppressMarkers: true,
    polylineOptions: {
      strokeColor: '#007bff',
      strokeWeight: 4
    }
  });

  estimatedDirectionsRenderer = new google.maps.DirectionsRenderer({
    map: map,
    suppressMarkers: true,
    polylineOptions: {
      strokeColor: '#28a745',
      strokeWeight: 3,
      strokeOpacity: 0.8
    }
  });

  setupControls();
  setupDragAndDrop();
  
  showActualItinerary();
  showEstimatedItinerary();
}

function setupControls() {
  const showActualCheckbox = document.getElementById('showActual');
  const showEstimatedCheckbox = document.getElementById('showEstimated');

  showActualCheckbox.addEventListener('change', function() {
    toggleActualRoute(this.checked);
  });

  showEstimatedCheckbox.addEventListener('change', function() {
    toggleEstimatedRoute(this.checked);
  });

  document.getElementById('restorePanels').addEventListener('click', restoreAllPanels);
}

function setupDragAndDrop() {
  const panels = document.querySelectorAll('.draggable-panel');
  
  panels.forEach(panel => {
    const header = panel.querySelector('.panel-header');
    
    header.addEventListener('mousedown', (e) => {
      if (e.target.classList.contains('collapse-btn')) return;
      
      draggedPanel = panel;
      isDragging = true;
      
      const rect = panel.getBoundingClientRect();
      dragOffset.x = e.clientX - rect.left;
      dragOffset.y = e.clientY - rect.top;
      
      panel.style.transition = 'none';
      document.body.style.cursor = 'grabbing';
      e.preventDefault();
    });
  });
  
  document.addEventListener('mousemove', (e) => {
    if (isDragging && draggedPanel) {
      const x = e.clientX - dragOffset.x;
      const y = e.clientY - dragOffset.y;
      
      // Keep panels within viewport
      const maxX = window.innerWidth - draggedPanel.offsetWidth;
      const maxY = window.innerHeight - draggedPanel.offsetHeight;
      
      draggedPanel.style.left = Math.max(0, Math.min(x, maxX)) + 'px';
      draggedPanel.style.top = Math.max(0, Math.min(y, maxY)) + 'px';
      draggedPanel.style.bottom = 'auto';
      draggedPanel.style.right = 'auto';
    }
  });
  
  document.addEventListener('mouseup', () => {
    if (isDragging && draggedPanel) {
      draggedPanel.style.transition = 'all 0.3s ease';
      document.body.style.cursor = 'default';
    }
    isDragging = false;
    draggedPanel = null;
  });
}

function togglePanel(panelId) {
  const panel = document.getElementById(panelId);
  const btn = panel.querySelector('.collapse-btn');
  const restoreBtn = document.getElementById('restorePanels');
  
  panel.classList.toggle('collapsed');
  
  if (panel.classList.contains('collapsed')) {
    btn.innerHTML = '+';
    restoreBtn.classList.add('show');
  } else {
    btn.innerHTML = '‚àí';
  }
  
  // Check if any panels are collapsed
  const collapsedPanels = document.querySelectorAll('.draggable-panel.collapsed');
  if (collapsedPanels.length === 0) {
    restoreBtn.classList.remove('show');
  }
}

function restoreAllPanels() {
  const panels = document.querySelectorAll('.draggable-panel');
  const restoreBtn = document.getElementById('restorePanels');
  
  panels.forEach(panel => {
    panel.classList.remove('collapsed');
    const btn = panel.querySelector('.collapse-btn');
    btn.innerHTML = '‚àí';
  });
  
  restoreBtn.classList.remove('show');
}

function toggleActualRoute(visible) {
  if (visible) {
    directionsRenderer.setMap(map);
    actualPolylines.forEach(polyline => polyline.setMap(map));
    actualMarkers.forEach(marker => marker.setMap(map));
  } else {
    directionsRenderer.setMap(null);
    actualPolylines.forEach(polyline => polyline.setMap(null));
    actualMarkers.forEach(marker => marker.setMap(null));
  }
}

function toggleEstimatedRoute(visible) {
  if (visible) {
    estimatedDirectionsRenderer.setMap(map);
    estimatedPolylines.forEach(polyline => polyline.setMap(map));
    estimatedMarkers.forEach(marker => marker.setMap(map));
  } else {
    estimatedDirectionsRenderer.setMap(null);
    estimatedPolylines.forEach(polyline => polyline.setMap(null));
    estimatedMarkers.forEach(marker => marker.setMap(null));
  }
}

function createSimplePointIcon(color, size = 8) {
  return {
    url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
      <svg xmlns="http://www.w3.org/2000/svg" width="${size * 2}" height="${size * 2}" viewBox="0 0 ${size * 2} ${size * 2}">
        <circle cx="${size}" cy="${size}" r="${size - 1}" fill="${color}" stroke="#ffffff" stroke-width="2"/>
      </svg>
    `),
    scaledSize: new google.maps.Size(size * 2, size * 2),
    anchor: new google.maps.Point(size, size)
  };
}

function createAlphabetIcon(letter, color, size = 24) {
  return {
    url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
      <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
        <rect x="2" y="2" width="${size - 4}" height="${size - 4}" rx="4" fill="${color}" stroke="#ffffff" stroke-width="2"/>
        <text x="${size/2}" y="${size/2 + 6}" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="white">${letter}</text>
      </svg>
    `),
    scaledSize: new google.maps.Size(size, size),
    anchor: new google.maps.Point(size/2, size)
  };
}

function showActualItinerary() {
  const jobId = getJobIdFromURL();
  if (!jobId) {
    console.error("Aucun jobId trouv√© dans l'URL.");
    return;
  }

  fetch(`/api/job/itinerary/${jobId}`)
    .then(response => response.json())
    .then(points => {
      actualPoints = points;

      if (!points || points.length < 2) {
        console.warn("Pas assez de points pour tracer l'itin√©raire r√©el.");
        return;
      }

      const origin = new google.maps.LatLng(points[0].latitude, points[0].longitude);
      const destination = new google.maps.LatLng(points[points.length - 1].latitude, points[points.length - 1].longitude);

      let waypointList = points.slice(1, -1);
      if (waypointList.length > MAX_WAYPOINTS) {
        const factor = Math.ceil(waypointList.length / MAX_WAYPOINTS);
        waypointList = waypointList.filter((_, i) => i % factor === 0);
      }

      const waypoints = waypointList.map(p => ({
        location: new google.maps.LatLng(p.latitude, p.longitude),
        stopover: true,
      }));

      const request = {
        origin,
        destination,
        waypoints,
        travelMode: google.maps.TravelMode.DRIVING,
        optimizeWaypoints: false,
      };

      directionsService.route(request, (result, status) => {
        if (status === google.maps.DirectionsStatus.OK) {
          directionsRenderer.setDirections(result);

          points.forEach((point, index) => {
            const marker = new google.maps.Marker({
              position: new google.maps.LatLng(point.latitude, point.longitude),
              map: map,
              title: `Point r√©el ${index + 1}`,
              icon: createSimplePointIcon('#dc3545'),
              zIndex: 500 + index
            });

            actualMarkers.push(marker);

            const infoWindow = new google.maps.InfoWindow({
              content: `
                <div>
                  <h6>Point r√©el ${index + 1}</h6>
                  <p>Lat: ${point.latitude.toFixed(6)}</p>
                  <p>Lng: ${point.longitude.toFixed(6)}</p>
                  ${point.timestamp ? `<p>Temps: ${new Date(point.timestamp).toLocaleString()}</p>` : ''}
                </div>
              `
            });
            marker.addListener('click', () => {
              infoWindow.open(map, marker);
            });
          });
        }
      });
    })
    .catch(err => {
      console.error("Erreur lors du fetch de l'itin√©raire r√©el :", err);
    });
}

function showEstimatedItinerary() {
  const jobId = getJobIdFromURL();
  if (!jobId) {
    console.error("Aucun jobId trouv√© dans l'URL.");
    return;
  }

  fetch(`/api/job/estimated-itinerary/${jobId}`)
    .then(response => response.json())
    .then(points => {
      if (!points || points.length < 2) {
        console.warn("Pas assez de points pour tracer l'itin√©raire estim√©.");
        return;
      }

      const origin = new google.maps.LatLng(points[0].latitude, points[0].longitude);
      const destination = new google.maps.LatLng(points[points.length - 1].latitude, points[points.length - 1].longitude);

      let waypointList = points.slice(1, -1);
      if (waypointList.length > MAX_WAYPOINTS) {
        const factor = Math.ceil(waypointList.length / MAX_WAYPOINTS);
        waypointList = waypointList.filter((_, i) => i % factor === 0);
      }

      const waypoints = waypointList.map(p => ({
        location: new google.maps.LatLng(p.latitude, p.longitude),
        stopover: true,
      }));

      const request = {
        origin,
        destination,
        waypoints,
        travelMode: google.maps.TravelMode.DRIVING,
        optimizeWaypoints: false,
      };

      directionsService.route(request, (result, status) => {
        if (status === google.maps.DirectionsStatus.OK) {
          estimatedDirectionsRenderer.setDirections(result);

          points.forEach((point, index) => {
            let isWithin5km = false;
            let nearestDistKm = null;

            if (actualPoints && actualPoints.length > 0) {
              const estLatLng = new google.maps.LatLng(point.latitude, point.longitude);
              for (let ap of actualPoints) {
                const actLatLng = new google.maps.LatLng(ap.latitude, ap.longitude);
                const distMeters = google.maps.geometry.spherical.computeDistanceBetween(estLatLng, actLatLng);
                const distKm = distMeters / 1000.0;
                if (nearestDistKm === null || distKm < nearestDistKm) nearestDistKm = distKm;
                if (distMeters <= 5000) {
                  isWithin5km = true;
                  break;
                }
              }
            }

            const isArrived = point.isArrived || point.status === 'arrived' || point.arrived === true;
            const markerColor = (isArrived || isWithin5km) ? '#28a745' : '#dc3545';
            const statusText = (isArrived || isWithin5km) ? 'Arriv√© (r√©el < 5km)' : 'Non arriv√©';
            
            const letter = getAlphabetLetter(index);

            const marker = new google.maps.Marker({
              position: new google.maps.LatLng(point.latitude, point.longitude),
              map: map,
              title: `Site estim√© ${letter} - ${statusText}`,
              icon: createAlphabetIcon(letter, markerColor),
              zIndex: 1000 + index
            });

            estimatedMarkers.push(marker);

            const infoWindow = new google.maps.InfoWindow({
              content: `
                <div>
                  <h6>Site estim√© ${letter}</h6>
                  <p><strong>Statut:</strong> <span style="color: ${markerColor}; font-weight: bold;">${statusText}</span></p>
                  <p>Lat: ${point.latitude.toFixed(6)}</p>
                  <p>Lng: ${point.longitude.toFixed(6)}</p>
                  ${nearestDistKm !== null ? `<p>Distance au plus proche r√©el: ${nearestDistKm.toFixed(2)} km</p>` : ''}
                  ${point.timestamp ? `<p>Temps estim√©: ${new Date(point.timestamp).toLocaleString()}</p>` : ''}
                  ${point.arrivalTime && isArrived ? `<p>Temps d'arriv√©e: ${new Date(point.arrivalTime).toLocaleString()}</p>` : ''}
                </div>
              `
            });
            marker.addListener('click', () => {
              infoWindow.open(map, marker);
            });
          });
        }
      });
    })
    .catch(err => {
      console.error("Erreur lors du fetch de l'itin√©raire estim√© :", err);
    });
}

function getAlphabetLetter(index) {
  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  if (index < 26) {
    return alphabet[index];
  } else {
    const firstLetter = alphabet[Math.floor(index / 26) - 1];
    const secondLetter = alphabet[index % 26];
    return firstLetter + secondLetter;
  }
}

window.initMap = initMap;
</script>

	<script async defer
		src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCsA6hQ1C8D6IIeB_r2WDEEgPelvpUWIf8&libraries=geometry&callback=initMap">
  </script>
</body>
</html>